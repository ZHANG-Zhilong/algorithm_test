#include <iostream>#include <vector>#include <algorithm>#include <random>#include <memory>#include <queue>using namespace std;class Node {public:    int value;    int row;    int col;    Node(int value, int row, int col) {        this->value = value;        this->row = row;        this->col = col;    }};using NodePtr = shared_ptr<Node>;struct heapComp {    bool operator()(const NodePtr &a, const NodePtr &b) const {        return a->value > b->value;    }};class Code06_TrappingRainWater {public:    static int trapRainWater(vector<vector<int>> &heightMap) {        if (heightMap.empty() || heightMap[0].empty()) {            cerr << "heightMap is empty\n";            exit(-1);        }        int N = heightMap.size();        int M = heightMap[0].size();        vector<vector<bool>> isEnter(N, vector<bool>(M, false));        priority_queue<NodePtr, vector<NodePtr>, heapComp> heap;        //N行M列，将外框加入heap小根堆中        {            for (int i = 0; i < M; i++) {                isEnter[0][i] = true;                heap.push(make_shared<Node>(heightMap[0][i], 0, i));            }            for (int i = 0; i < M; i++) {                isEnter[N - 1][i] = true;                heap.push(make_shared<Node>(heightMap[N - 1][i], N - 1, i));            }            for (int i = 1; i < N - 1; i++) {                isEnter[i][0] = true;                heap.push(make_shared<Node>(heightMap[i][0], i, 0));            }            for (int i = 1; i < N - 1; i++) {                isEnter[i][M - 1] = true;                heap.push(make_shared<Node>(heightMap[i][M - 1], i, M - 1));            }        }        int water = 0, maxValue = 0;        //弹出一个元素, 更新 maxValue值， 将上下左右没有加入过小根堆的点加入小根堆同时结算水量        while (!heap.empty()) {            auto curNodePtr = heap.top();            heap.pop();            int row = curNodePtr->row, col = curNodePtr->col;            maxValue = max(curNodePtr->value, maxValue);            if (row - 1 >= 0 && !isEnter[row - 1][col]) {                water += max(0, maxValue - heightMap[row - 1][col]);                if (maxValue - heightMap[row - 1][col] > 0) {                    cout << "water: " << water << " " << row - 1 << " " << col << endl;                }                isEnter[row - 1][col] = true;                heap.push(make_shared<Node>(heightMap[row - 1][col], row - 1, col));            }            if (row + 1 < N && !isEnter[row + 1][col]) {                water += max(0, maxValue - heightMap[row + 1][col]);                if (maxValue - heightMap[row + 1][col] > 0) {                    cout << "water: " << water << " " << row + 1 << " " << col << endl;                }                isEnter[row + 1][col] = true;                heap.push(make_shared<Node>(heightMap[row + 1][col], row + 1, col));            }            if (col - 1 >= 0 && !isEnter[row][col - 1]) {                water += max(0, maxValue - heightMap[row][col - 1]);                if (maxValue - heightMap[row][col - 1] > 0) {                    cout << "water: " << water << " " << row << " " << col - 1 << endl;                }                isEnter[row][col - 1] = true;                heap.push(make_shared<Node>(heightMap[row][col - 1], row, col - 1));            }            if (col + 1 < M && !isEnter[row][col + 1]) {                water += max(0, maxValue - heightMap[row][col + 1]);                if (maxValue - heightMap[row][col + 1] > 0) {                    cout << "water: " << water << " " << row << " " << col + 1 << endl;                }                isEnter[row][col + 1] = true;                heap.push(make_shared<Node>(heightMap[row][col + 1], row, col + 1));            }        }        return water;    }};vector<int> getRandomArray(const int from, const int to, const int len) {    if (to < from || len < 1) {        return {};    }    random_device rd;    int range = to - from;    vector<int> ret(len, 0);    for (auto &n : ret) {        n = (double) rd() / rd.max() * range + from;    }    cout << "h" << endl;    return ret;}vector<vector<int>> getRandomMatrix(const int M, const int N, const int from, const int to) {    if (M <= 1 || N <= 1 || from > to) {        cerr << "input error @ getRandomMatrix" << endl;        return {};    }    vector<vector<int>> matrix;    for (int i = 0; i < M; i++) {        matrix.push_back(getRandomArray(from, to, N));    }    return matrix;}void printArr(const vector<int> arr) {    if (arr.empty()) {        return;    }    for (const auto &n : arr) {        cout << n << " ";    }    cout << endl;}void printMatrix(const vector<vector<int>> &matrix) {    for (const auto &m : matrix) {        for (const auto &n : m) {            cout << n << " ";        }        cout << endl;    }    cout << endl;}void play() {    auto matrix = getRandomMatrix(4, 4, 1, 25);    printMatrix(matrix);    cout << Code06_TrappingRainWater::trapRainWater(matrix);}int main(int argc, char *argv[]) {    play();    return 0;}