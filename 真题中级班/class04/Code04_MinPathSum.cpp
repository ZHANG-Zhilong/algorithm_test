#include <iostream>#include <vector>#include <random>#include <memory>using namespace std;class GetRandom {public:    static vector<int> getRandomArray(const int from, const int to, const int len) {        if (to < from || len < 1) {            return {};        }        random_device rd;        int range = to - from;        vector<int> ret(len, 0);        for (auto &n : ret) {            n = (double) rd() / rd.max() * range + from;        }        cout << endl;        return ret;    }    static vector<vector<int>> getRandomMatrix(const int M, const int N, const int from, const int to) {        if (M <= 1 || N <= 1 || from > to) {            cerr << "input error @ getRandomMatrix" << endl;            return {};        }        vector<vector<int>> matrix;        for (int i = 0; i < M; i++) {            matrix.push_back(getRandomArray(from, to, N));        }        return matrix;    }    static void printArr(const vector<int> arr) {        if (arr.empty()) {            return;        }        for (const auto &n : arr) {            cout << n << " ";        }        cout << endl;    }    static void printMatrix(const vector<vector<int>> &matrix) {        for (const auto &m : matrix) {            for (const auto &n : m) {                cout << n << " ";            }            cout << endl;        }        cout << endl;    }};class Code04_MinPathSum{public:    static int minPath(const vector<vector<int>>& matrix){        if(matrix.empty() || matrix[0].empty()){            return -1;        }        return process(matrix, 0, 0);    }private:    static int process(const vector<vector<int>>& matrix, int row, int col){        if(row == matrix.size()-1 && col == matrix[0].size()-1){            return matrix.back().back();        }        int right = INT32_MAX, down = INT32_MAX;        if(row+1<matrix.size()){            down = process(matrix, row+1, col);        }        if(col+1 < matrix[0].size()){            right = process(matrix, row, col+1);        }        return min(down, right) + matrix[row][col];    }public:    static int minPath2(const vector<vector<int>>& matrix){        if(matrix.empty() || matrix.front().empty()){            return -1;        }        //compress memory.        vector<int> dpc(matrix.size(), 0);        dpc.back() = matrix.back().back();        for(ssize_t j = matrix[0].size()-2; j>=0; j--){            dpc[j] = dpc[j+1] + matrix.back()[j];        }        for(ssize_t i = matrix.size()-2; i>=0; i--){            dpc.back() += matrix[i].back();            for(ssize_t j = matrix[i].size()-2; j>=0; j--){                dpc[j] = min(dpc[j], dpc[j+1])+matrix[i][j];            }        }        return dpc.front();    }};void play() {    vector<vector<int>> matrix{ { 1, 3, 5, 9 },                                { 8, 1, 3, 4 },                                { 5, 0, 6, 1 },                                { 8, 8, 4, 0 } };    cout<<Code04_MinPathSum::minPath(matrix)<<endl;    cout<<Code04_MinPathSum::minPath2(matrix)<<endl;}int main(int argc, char *argv[]) {    play();    return 0;}